<?php
// output contents type
header("Content-Type: text/css; charset=UTF-8");

if (!ini_get("date.timezone")) {
  date_default_timezone_set("Asia/Tokyo");
}

// detect source file
if (isset($argv)) { // command line
  if (count($argv) == 1) {
    echo "USAGE: php mkcss.php (infile)\n"; exit;
  }
  $mkfile = $argv[1];
  $nocache = TRUE;
} else {
  $f = isset($_GET["f"]) ? $_GET["f"] : "";
  $mkfile = dirname(__FILE__).'/'.$f.'.mkcss';
  if (!file_exists($mkfile)) {
    $mkfile = dirname(__FILE__).'/'.$f;
    if (!file_exists($mkfile)) {
      echo "/* file not found $f */"; exit;
    }
  }
  $nocache = isset($_GET["nocahce"]) ? $_GET["nocache"] : true;
}

// check cache file
$cssfile = preg_replace('/\.mkcss$/', '.css', $mkfile);
if ($cssfile == $mkfile) $cssfile .= ".css";
if (!$nocache) {
  if (file_exists($cssfile)) {
    $time_css = filemtime($cssfile);
    $time_mk  = filemtime($mkfile);
    if ($time_css > $time_mk) {
      $css = file_get_contents($cssfile);
      echo $css; exit;
    }
  }
}

// load & generate
$mtime = date("Y-m-d H:i:s",filemtime($mkfile));
$src = @file_get_contents($mkfile);

$parser = new mkcss_parser();
$css = $parser->compile($src);

$css = "/* {$f} ({$mtime}) --- generated by mkcss.php */\n\n".$css;
echo $css;
@file_put_contents($cssfile, $css);


class mkcss_scope {
  public $parent = NULL;
  public $children = array();
  public $variables = array();
  public $indent = 0;
  public $items = array();
  public $name = "";
  public $is_mixin = FALSE;

  public function __construct($parent) {
    $this->parent = $parent;
    if ($parent != NULL) {
      $parent->children[] = $this;
    }
  }

  public function find_var($name) {
    if (isset($this->variables[$name])) {
      $v = $this->variables[$name];
      return $v;
    }
    if ($this->parent == NULL) {
      return NULL;
    }
    return $this->parent->find_var($name);
  }

  protected function get_name_r() {
    $cur = $this;
    $name = "";
    for (;;) {
      // @media
      if (substr($cur->name, 0, 6) == "@media") break;
      // path
      $name = $cur->name . ' ' . $name;
      if ($cur->parent == NULL) break;
      if ($cur->parent->name == "") break;
      $cur = $cur->parent;
    }
    return trim($name);
  }

  public function gen_css() {
    $css = "";

    // @media
    if (substr($this->name, 0, 6) == '@media') {
      $css .= $this->name." {\n";
      // children
      foreach ($this->children as $child) {
        $css .= $child->gen_css();
      }
      $css .= "}\n";
      return $css;
    }

    // current scope
    foreach ($this->items as $name => $value) {
      $css .= "$name: $value; ";
    }
    $name = $this->get_name_r();
    if ($name != "") {
      $css = "$name { $css }\n";
    }
    // children scope
    foreach ($this->children as $child) {
      $css .= $child->gen_css();
    }
    return $css;
  }
}

class mkcss_parser {

  protected $calculator;
  protected $root_scope;
  protected $scope;
  protected $mixins = array();
  public $indent_tab_count = 4;

  public function __construct() {
    $this->root_scope = new mkcss_scope(NULL);
    $this->scope = $this->root_scope;
    $this->calculator = new mkcss_calc();
    $this->calculator->set_scope($this->scope);
  }

  protected function calc($v) {
    return $this->calculator->calc($v);
  }

  public function compile($src) {
    $this->analyze_source($src);
    $css = $this->root_scope->gen_css();
    return $css;
  }

  private function count_indent($line) {
    if (!preg_match('/^(\s+)/', $line, $m)) return 0;
    $spc = $m[1];
    $spc_a = str_split($spc);
    $i = 0;
    foreach ($spc_a as $c) {
      switch ($c) {
        case ' ' : $i += 1; break;
        case "\t": $i += $this->indent_tab_count; break;
      }
    }
    return $i;
  }

  private function analyze_mixin_args($arg_str) {
    $vars = array();
    $arg_str = str_replace("=", ":", $arg_str);
    $arg_a = explode(",", $arg_str);
    foreach($arg_a as $a) {
      $v_a = explode(":", $a, 2);
      $v_name  = trim($v_a[0]);
      $v_value = isset($v_a[1]) ? trim($v_a[1]) : "";
      $vars[$v_name] = $v_value;
    }
    return $vars;
  }

  private function analyze_mixin(&$scope, $line) {
    if (preg_match('#^\@mixin ([a-zA-Z0-9_\-]+)\((.*?)\)\s*\:$#', $line, $m)) {
      $name = $m[1];
      $arg_str = $m[2];
      $scope = new mkcss_scope(NULL);
      $scope->name = $name;
      $scope->indent = 0;
      $scope->is_mixin = TRUE;
      $this->mixins[$name] = $scope;
      $scope->variables = $this->analyze_mixin_args($arg_str);
      return true;
    }
    // include mixin
    if (preg_match('#\@include ([a-zA-Z0-9_\-]+)\((.*?)\)#', $line, $m)) {
      $name = $m[1];
      $args = explode(",", $m[2]);
      if (isset($this->mixins[$name])) {
        $mixin = $this->mixins[$name];
        // set arguments to variables
        foreach ($mixin->variables as $v_name => $v_value) {
          $v = trim(array_shift($args));
          if ($v != NULL) {
            $scope->variables[$v_name] = $v;
          } else {
            $scope->variables[$v_name] = $v_value;
          }
        }
        // mixin items
        foreach ($mixin->items as $i_name => $i_value) {
          $scope->items[$i_name] = $this->calc($i_value);
        }
      }
      return true;
    }
    return false;
  }

  protected function analyze_source($src) {
    $lineno = 0;
    $scope = $this->scope;
    $lines = explode("\n", $src);
    while ($lines) {
      $line = array_shift($lines);
      $lineno++;

      // count indent
      $indent = $this->count_indent($line);
      $line = trim($line);
      if ($line == "") continue;
      // echo "line:$indent:$line\n";

      // inc indent?
      if ($scope->indent < $indent) {
        $scope->indent = $indent;
      }
      // dec indent (change scope)?
      else if ($scope->indent > $indent) {
        while ($scope->indent > $indent) {
          $scope = $scope->parent;
          if ($scope == NULL) $scope = $this->root_scope;
        }
        $this->calculator->set_scope($scope);
      }

      // important comment?
      if (substr($line, 0, 3) == "///") {
        $line = substr($line, 3);
        $res["///".$lineno] = "/* {$line} */";
        continue;
      }
      // remove comment
      $line = trim(preg_replace('#\/\/.*$#', '', $line));
      if ($line == "") continue;

      // define variable?
      $c = substr($line, 0, 1);
      if ($c == '$') {
        if (preg_match('/(\$[a-zA-Z0-9_\-]+)\s*[\=\:](.*)$/', $line, $m)) {
          $v_name  = $m[1];
          $v_value = trim($m[2]);
          $scope->variables[$v_name] = $this->calc($v_value);
          continue;
        } else {
          echo "ERR: $line\n";
        }
      }

      // mixin?
      if ($this->analyze_mixin($scope, $line)) continue;

      // css name? ... new scope
      if (preg_match('#(.+)\:$#', $line, $m)) {
        $scope = new mkcss_scope($scope);
        $scope->name = $m[1];
        $scope->indent = $indent;
        $this->calculator->set_scope($scope);
        continue;
      }

      // items?
      if (preg_match('/^(.+?)\:(.+)$/', $line, $m)) {
        $item_name  = $m[1];
        $item_value = $m[2];
        if ($scope->is_mixin) {
          $scope->items[$item_name] = $item_value;
        } else {
          $scope->items[$item_name] = $this->calc($item_value);
        }
        continue;
      }

      // others
      $scope->items['>>>'.$lineno] = $line;
    }
  }
}

class mkcss_token {
  public $priority;
  public $value;
  public $type;
  //
  public $children = array();
  public $parent = NULL;

  public function __construct($priority, $type, $value) {
    $this->priority = $priority;
    $this->type = $type;
    $this->value = $value;
  }
}

class mkcss_calc {

  protected $scope;
  protected $tokens = array();
  protected $nodes = array();
  protected $results = array();


  public function set_scope($scope) {
    $this->scope = $scope;
  }

  public function calc($v) {
    $v = trim($v);

    // simple string value (ex)red / blue
    if (preg_match('#^[a-zA-Z\_\-]+$#', $v)) {
      return $v;
    }
    // simple numeric value (ex)4px
    if (preg_match('#^[0-9]+[a-zA-Z]*$#', $v)) {
      return $v;
    }

    // check value
    $this->tokenize($v);
    $this->parse();
    $this->run();
    return implode(" ", $this->results);
  }

  private function tokenize($str) {
    $tokens = array();
    while ($str != "") {
      $tokens[] = $this->get_element($str);
    }
    $this->tokens = $tokens;
  }

  private function parse() {
    while ($this->tokens) {
      $v = $this->parse_exp();
      if ($v !== null) {
        array_push($this->nodes, $v);
        continue;
      }
      // null
      array_shift($this->tokens);
    }
  }

  private function parse_exp() {
    $va = $this->parse_value();
    if ($va == null) return null;
    $next_type = $this->token_type0();
    if ($next_type == "op") {
      $op = array_shift($this->tokens);
      $op->children[0] = $va;
      $vb = $this->parse_exp();
      $top = $op;
      if ($vb->type == "op") {
        if ($vb->priority > $op->priority) {
          $top->children[1] = $vb;
        } else {
          $vb_l = $vb->children[0];
          $vb->children[0] = $op;
          $op->children[1] = $vb_l;
          $top = $vb;
        }
      } else {
        $top->children[1] = $vb;
      }
      return $top;
    }
    return $va;
  }

  private function parse_value() {
    $t = array_shift($this->tokens);
    if ($t == NULL) return NULL;
    // num
    if ($t->type == "num" || $t->type == "str") {
      return $t;
    }
    // (...)
    if ($t->value == '(') {
      $list = array();
      for (;;) {
        $v = $this->parse_exp();
        $list[] = $v;
        if (count($this->tokens) == 0) break;
        $t2 = $this->tokens[0];
        if ($t2->value == ')') {
          array_shift($this->tokens);
          break;
        }
      }
      $cnt = count($list);
      if ($cnt == 0) return null;
      if ($cnt == 1) return $list[0];
      return new mkcss_token(1, "list", $list);
    }
    return null;
  }

  private function token_type0() {
    if (!$this->tokens) return "end";
    $t = $this->tokens[0];
    return $t->type;
  }

  private function run() {
    $this->results = array();
    while ($this->nodes) {
      $node = array_shift($this->nodes);
      $v = $this->_run($node);
      array_push($this->results, $v);
    }
  }

  private function _run($node) {
    if ($node == null) return 0;
    switch ($node->type) {
      case "num":
      case "str":
        return $node->value;
      case "op":
        $a = $this->_run($node->children[0]);
        $b = $this->_run($node->children[1]);
        $unit = "";
        if (preg_match('#([a-z]+)$#', $b, $m)) {
          $unit = $m[1];
        }
        $c = 0;
        switch ($node->value) {
          case "+" : $c = $a + $b; break;
          case "-" : $c = $a - $b; break;
          case "*" : $c = $a * $b; break;
          case "/" : $c = $a / $b; break;
          case "%" : $c = $a % $b; break;
          case ">" : $c = $a > $b; break;
          case ">=": $c = $a >= $b; break;
          case "<" : $c = $a < $b; break;
          case "<=": $c = $a <= $b; break;
        }
        if ($unit != "") $c .= $unit;
        return $c;
      case "list":
        $list = array();
        foreach ($node->value as $v) {
          $list[] = $this->_run($v);
        }
        return implode(" ", $list);
      default:
        return 0;
    }
    return 0;
  }

  private function _parse($str) {
    $stack = array();
    $res = array();
    while ($str != "") {
      $v = $this->get_element($str);
      if ($v == NULL) break;
      // echo "[{$v[2]}]";
      if ($v[1] == 'num' || $v[1] == 'str') {
        array_push($res, $v);
        continue;
      }
      else if ($v[2] == ')') {
        for (;;) {
          if (count($stack) == 0) break;
          $e = array_pop($stack);
          if ($e[2] == '(') break;
          array_push($res, $e);
        }
        continue;
      }
      else if ($v[2] == '(') {
        array_push($stack, $v);
        continue;
      }
      else if ($v[1] == 'op') {
        for(;;) {
          if (count($stack) == 0) {
            array_push($stack, $v);
            break;
          }
          // check stack top
          $top = stack_top($stack);
          if ($top[0] > $v[0]) { // priority high
            array_push($stack, $v);
            break;
          }
          $e = array_pop($stack);
          array_push($res, $e);
        }
      }
    }
    while (count($stack) > 0) {
      array_push($res, array_pop($stack));
    }
    return $res;
  }

  // return array(priority, name, value)
  private function get_element(&$v) {
    $v = trim($v);
    if ($v == "") return NULL;
    $c = substr($v, 0, 1);
    // number (ex)4px 0.5em
    if (preg_match('#^([0-9\.]+[a-zA-Z]*)#', $v, $m)) {
      $num = $m[1];
      $v = substr($v, strlen($num));
      return new mkcss_token(1, 'num', $num);
    }
    $v = trim($v);
    // variable
    if ($c == '$') {
      preg_match('#^(\$[a-zA-Z0-9_]*)#', $v, $m);
      $var_name = $m[1];
      $v = substr($v, strlen($var_name));
      $vn = $this->scope->find_var($var_name);
      if ($vn == NULL) {
        return new mkcss_token(1, 'str', $var_name);
      } else {
        if (is_numeric($vn)) {
          return new mkcss_token(1, 'num', $vn);
        } else {
          return new mkcss_token(1, 'str', $vn);
        }
      }
    }
    // color code
    if ($c == '#') {
      preg_match('#^(\#[a-fA-F0-9]*)#', $v, $m);
      $str = $m[1];
      $v = substr($v, strlen($str));
      return new mkcss_token(1, 'str', $str);
    }
    // operator
    if ($c == '>' || $c == '<' || $c == '>=' || $c == '<=') {
      $v = substr($v, 1);
      return new mkcss_token(1, 'op', $c);
    }
    if ($c == '+' || $c == '-') {
      $v = substr($v, 1);
      return new mkcss_token(2, 'op', $c);
    }
    if ($c == '*' || $c == '/' || $c == '%') {
      $v = substr($v, 1);
      return new mkcss_token(3, 'op', $c);
    }
    if ($c == '(' || $c == ')') {
      $v = substr($v, 1);
      return new mkcss_token(0, 'flag', $c);
    }
    // css function
    if (preg_match('#^([a-zA-Z\_\-]+\(.+?\))#', $v, $m)) {
      $str = $m[1];
      $v = substr($v, strlen($str));
      return new mkcss_token(1, 'str', $str);
    }
    // str
    if (preg_match('#^([a-zA-Z\_\-0-9]+)#', $v, $m)) {
      $str = $m[1];
      $v = substr($v, strlen($str));
      return new mkcss_token(1, 'str', $str);
    }
    // others
    $v = substr($v, 1);
    return new mkcss_token(1, 'str', $v);
  }
}

function stack_top($a) {
  if (count($a) == 0) return null;
  return $a[count($a) - 1];
}
